AWSTemplateFormatVersion: '2010-09-09'
Description: A stack for deploying containerized applications onto a cluster of EC2
             hosts using Elastic Container Service. This stack runs containers on
             hosts that are in a private VPC subnet. Outbound network traffic from the
             hosts must go out through a NAT gateway. There is one load balancers
             inside the public subnet, which can be used to send traffic to the
             containers in the private subnet.
Parameters:
  ServiceName:
    Type: String
    Description: A name for the service
    Default: Cvat
  DesiredCapacity:
    Type: Number
    Default: '1'
    Description: Number of EC2 instances to launch in your ECS cluster.
  MaxSize:
    Type: Number
    Default: '4'
    Description: Maximum number of EC2 instances that can be launched in your ECS cluster.
  InstanceType:
    Description: EC2 instance type
    Type: String
    Default: t2.small
  KeyPairName:
    Type: String
    Description: Name of an existing EC2 KeyPair to enable SSH access to the ECS instances
  EFSNameTag:
    Description: The name of the EFS volume
    Type: String
    MinLength: '1'
    Default: myEFSvolume
  SSLCertificateArn:
    Description: SSL certificate arn
    Type: String
  HostedZoneName:
    Description: hosted zone
    Type: String
    Default: datarock.com.au.
  HostName:
    Description: host name
    Type: String
    Default: label
  ApiHostName:
    Description: Api host name
    Type: String
    Default: label
  SpotPrice:
    Description: Spot price to bid
    Type: Number
    Default: 0.2336
  VpcId:
    Type: String
  PrivateSubnetOne:
    Type: String
  PrivateSubnetTwo:
    Type: String
  PrivateSubnetThree:
    Type: String
  PublicSubnetOne:
    Type: String
  PublicSubnetTwo:
    Type: String
  PublicSubnetThree:
    Type: String
  BastionSecurityGroup:
    Type: String

Mappings:
  AWSRegionToAMI:
    us-east-1:
      AMIID: ami-a88a46c5
    us-west-2:
      AMIID: ami-ae0acdce
    us-west-1:
      AMIID: ami-34a7e354
    eu-west-1:
      AMIID: ami-ccd942bf
    eu-central-1:
      AMIID: ami-4a5eb625
    ap-southeast-1:
      AMIID: ami-24c71547
    ap-northeast-1:
      AMIID: ami-4aab5d2b
    # ami-0106613df14f2f5d7
    ap-southeast-2:
      AMIID: ami-0bf2da68

Resources:
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join ['-', [!Ref ServiceName, Cluster]]

  EcsSecurityGroupIngressFromBastion:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from Bastion to EcsInstance
      GroupId: !Ref 'ContainerSecurityGroup'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'BastionSecurityGroup'

  MountTargetSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref 'VpcId'
      GroupDescription: Security group for mount target
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: '2049'
          ToPort: '2049'
          SourceSecurityGroupId: !Ref 'ContainerSecurityGroup'
  FileSystem:
    Type: AWS::EFS::FileSystem
    Properties:
      FileSystemTags:
        - Key: Name
          Value: !Ref 'EFSNameTag'
  MountTargetOne:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref 'FileSystem'
      SubnetId: !Ref 'PrivateSubnetOne'
      SecurityGroups:
        - !Ref 'MountTargetSecurityGroup'
  MountTargetTwo:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref 'FileSystem'
      SubnetId: !Ref 'PrivateSubnetTwo'
      SecurityGroups:
        - !Ref 'MountTargetSecurityGroup'
  MountTargetThree:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref 'FileSystem'
      SubnetId: !Ref 'PrivateSubnetThree'
      SecurityGroups:
        - !Ref 'MountTargetSecurityGroup'

  # A security group for the EC2 hosts that will run the containers.
  # Two rules, allowing network traffic from a public facing load
  # balancer and from other hosts in the security group.
  #
  # Remove any of the following ingress rules that are not needed.
  # If you want to make direct requests to a container using its
  # public IP address you'll need to add a security group rule
  # to allow traffic from all IP addresses.
  ContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the ECS hosts that run containers
      VpcId: !Ref 'VpcId'
  EcsSecurityGroupIngressFromPublicALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the public ALB
      GroupId: !Ref 'ContainerSecurityGroup'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'PublicAppLoadBalancerSG'
  EcsSecurityGroupIngressFromSelf:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from other containers in the same security group
      GroupId: !Ref 'ContainerSecurityGroup'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'ContainerSecurityGroup'

  # Autoscaling group. This launches the actual EC2 instances that will register
  # themselves as members of the cluster, and run the docker containers.

  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn:
      - MountTargetOne
      - MountTargetTwo
      - MountTargetThree
    Properties:
      AvailabilityZones:
        - !Select
          - '0'
          - !GetAZs
            Ref: AWS::Region
        - !Select
          - '1'
          - !GetAZs
            Ref: AWS::Region
        - !Select
          - '2'
          - !GetAZs
            Ref: AWS::Region
      VPCZoneIdentifier:
        - !Ref PrivateSubnetOne
        - !Ref PrivateSubnetTwo
        - !Ref PrivateSubnetThree
      LaunchConfigurationName: !Ref 'ContainerInstances'
      MinSize: '0'
      MaxSize: !Ref 'MaxSize'
      DesiredCapacity: !Ref 'DesiredCapacity'
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'

  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          Install:
            - Install
        Install:
          packages:
            yum:
              nfs-utils: []
              python27: []
          files:
            /etc/cfn/cfn-hup.conf:
              content: !Join
                - ''
                - - "[main]\n"
                  - stack=
                  - !Ref 'AWS::StackId'
                  - "\n"
                  - region=
                  - !Ref 'AWS::Region'
                  - "\n"
              mode: '000400'
              owner: root
              group: root
            /etc/cfn/hooks.d/cfn-auto-reloader.conf:
              content: !Join
                - ''
                - - "[cfn-auto-reloader-hook]\n"
                  - "triggers=post.update\n"
                  - "path=Resources.ContainerInstances.Metadata.AWS::CloudFormation::Init\n"
                  - 'action=/opt/aws/bin/cfn-init -v '
                  - '         --stack '
                  - !Ref 'AWS::StackName'
                  - '         --resource ContainerInstances '
                  - '         --region '
                  - !Ref 'AWS::Region'
                  - "\n"
                  - "runas=root\n"
          services:
            sysvinit:
              cfn-hup:
                enabled: 'true'
                ensureRunning: 'true'
                files:
                  - /etc/cfn/cfn-hup.conf
                  - /etc/cfn/hooks.d/cfn-auto-reloader.conf
      AWS::CloudFormation::Designer:
        id: d86a3e51-ef74-4f2a-9591-8c547b7bee6c
    Properties:
      ImageId: !FindInMap
        - AWSRegionToAMI
        - !Ref 'AWS::Region'
        - AMIID
      BlockDeviceMappings:
        - DeviceName: /dev/xvdcz
          Ebs:
            DeleteOnTermination: true
            Encrypted: false
            Iops: 100
            VolumeSize: 22 # minimum required to store the container layer infos
            VolumeType: gp2
      InstanceType: !Ref 'InstanceType'
      SpotPrice: !Ref SpotPrice
      IamInstanceProfile: !Ref 'EC2InstanceProfile'
      KeyName: !Ref 'KeyPairName'
      AssociatePublicIpAddress: false
      SecurityGroups:
        - !Ref ContainerSecurityGroup
      UserData: !Base64
        Fn::Join:
          - ''
          - - "#!/bin/bash\n"
            - echo ECS_CLUSTER=
            - !Ref 'ECSCluster'
            - " >> /etc/ecs/ecs.config\n"
            - "yum install -y aws-cfn-bootstrap\n"
            - /opt/aws/bin/cfn-init
            - '         --stack '
            - !Ref 'AWS::StackName'
            - ' '
            - '         --resource ContainerInstances '
            - '         --configsets Install '
            - '         --region '
            - !Ref 'AWS::Region'
            - "\n"
            - "PATH=$PATH:/usr/local/bin\n"
            - "yum update\n"
            - "EC2_AVAIL_ZONE=`curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone`\n"
            - EC2_REGION=
            - !Ref 'AWS::Region'
            - "\n"
            - "mkdir /mnt/efs\n"
            - EFS_FILE_SYSTEM_ID=
            - !Ref 'FileSystem'
            - "\n"
            - "DIR_SRC=$EC2_AVAIL_ZONE.$EFS_FILE_SYSTEM_ID.efs.$EC2_REGION.amazonaws.com\n"
            - "DIR_TGT=/mnt/efs\n"
            - "touch /home/ec2-user/echo.res\n"
            - "echo $EFS_FILE_SYSTEM_ID >> /home/ec2-user/echo.res\n"
            - "echo $EC2_AVAIL_ZONE >> /home/ec2-user/echo.res\n"
            - "echo $EC2_REGION >> /home/ec2-user/echo.res\n"
            - "echo $DIR_SRC >> /home/ec2-user/echo.res\n"
            - "echo $DIR_TGT >> /home/ec2-user/echo.res\n"
            - "mount -t nfs4 $DIR_SRC:/ $DIR_TGT >> /home/ec2-user/echo.res\n"
            - "cp -p /etc/fstab /etc/fstab.back-$(date +%F)\n"
            - "echo -e \"$DIR_SRC:/ \t\t $DIR_TGT \t\t nfs \t\t defaults \t\t 0 \t\
              \t 0\" | tee -a /etc/fstab\n"
            - "sudo chmod 777 -R /mnt/efs\n"
            - "sudo chmod 777 -R /mnt/efs/*\n"
            - "docker ps\n"
            - "service docker stop\n"
            - "service docker start\n"
            - '/opt/aws/bin/cfn-signal -e $? '
            - '         --stack '
            - !Ref 'AWS::StackName'
            - '         --resource ECSAutoScalingGroup '
            - '         --region '
            - !Ref 'AWS::Region'
            - "\n"
  AutoscalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [application-autoscaling.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: service-autoscaling
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              - 'application-autoscaling:*'
              - 'cloudwatch:DescribeAlarms'
              - 'cloudwatch:PutMetricAlarm'
              - 'ecs:DescribeServices'
              - 'ecs:UpdateService'
            Resource: '*'
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref 'EC2Role']



  # Role for the EC2 hosts. This allows the ECS agent on the EC2 hosts
  # to communciate with the ECS control plane, as well as download the docker
  # images from ECR to run on your host.
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role

  # A public facing load balancer, this is used for accepting traffic from the public
  # internet and directing it to public facing microservices
  PublicAppLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId: !Ref 'VpcId'
      SecurityGroupIngress:
          # Allow access to ALB from anywhere on the internet
          - CidrIp: 0.0.0.0/0
            IpProtocol: tcp
            FromPort: '80'
            ToPort: '80'
          - CidrIp: 0.0.0.0/0
            IpProtocol: tcp
            FromPort: '443'
            ToPort: '443'
  PublicAppLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
      - Key: idle_timeout.timeout_seconds
        Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic
        # from the internet can reach the load balancer directly via the internet gateway
        - !Ref PublicSubnetOne
        - !Ref PublicSubnetTwo
        - !Ref PublicSubnetThree
      SecurityGroups: [!Ref 'PublicAppLoadBalancerSG']
  # A dummy target group is used to setup the ALB to just drop traffic
  # initially, before any real service target groups have been added.
  DummyTargetGroupPublic:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Name: !Sub '${ServiceName}-Dummy-Drop-One'
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref 'VpcId'

  PublicAppLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PublicAppLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'DummyTargetGroupPublic'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PublicAppLoadBalancer'
      # Port: 80
      # Protocol: HTTP
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificateArn

  # Redirect HTTP to HTTPS
  PublicAppLoadBalancerHttpRedirectListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PublicAppLoadBalancer
    Properties:
      DefaultActions:
        - RedirectConfig:
            Host: '#{host}'
            Path: '/#{path}'
            Port: 443
            Protocol: 'HTTPS'
            Query: '#{query}'
            StatusCode: HTTP_301
          Type: redirect
      LoadBalancerArn: !Ref 'PublicAppLoadBalancer'
      Port: 80
      Protocol: HTTP

  ClusterDNSRecord:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneName: !Ref HostedZoneName
      Comment: Zone apex alias targeted to ALB of Cluster.
      RecordSets:
      - Name:
          Fn::Join: ["", [!Ref HostName, ".", !Ref HostedZoneName]]
        Type: A
        AliasTarget:
          HostedZoneId: !GetAtt PublicAppLoadBalancer.CanonicalHostedZoneID
          DNSName: !GetAtt PublicAppLoadBalancer.DNSName
      - Name:
          Fn::Join: ["", [!Ref ApiHostName, ".", !Ref HostedZoneName]]
        Type: A
        AliasTarget:
          HostedZoneId: !GetAtt PublicAppLoadBalancer.CanonicalHostedZoneID
          DNSName: !GetAtt PublicAppLoadBalancer.DNSName

  # This is an IAM role which authorizes ECS to manage resources on your
  # account on your behalf, such as updating your load balancer with the
  # details of where your containers are, so that traffic can reach your
  # containers.
  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              # Rules which allow ECS to attach network interfaces to instances
              # on your behalf in order for awsvpc networking mode to work right
              - 'ec2:AttachNetworkInterface'
              - 'ec2:CreateNetworkInterface'
              - 'ec2:CreateNetworkInterfacePermission'
              - 'ec2:DeleteNetworkInterface'
              - 'ec2:DeleteNetworkInterfacePermission'
              - 'ec2:Describe*'
              - 'ec2:DetachNetworkInterface'

              # Rules which allow ECS to update load balancers on your behalf
              # with the information sabout how to send traffic to your containers
              - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
              - 'elasticloadbalancing:DeregisterTargets'
              - 'elasticloadbalancing:Describe*'
              - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
              - 'elasticloadbalancing:RegisterTargets'
            Resource: '*'

# These are the values output by the CloudFormation template. Be careful
# about changing any of them, because of them are exported with specific
# names so that the other task related CF templates can use them.

Outputs:
  ClusterName:
    Description: The name of the ECS cluster
    Value: !Ref 'ECSCluster'
  ExternalUrl:
    Description: The url of the external load balancer
    Value: !Join ['', ['http://', !GetAtt 'PublicAppLoadBalancer.DNSName']]
  ExternalDNSName:
    Description: The ExternalDNSName of the external load balancer
    Value: !GetAtt 'PublicAppLoadBalancer.DNSName'
  ECSRole:
    Description: The ARN of the ECS role
    Value: !GetAtt 'ECSRole.Arn'
  PublicLoadBalancerListener:
    Description: The ARN of the public load balancer's Listener
    Value: !Ref PublicAppLoadBalancerListener
  ContainerSecurityGroup:
    Description: A security group used to allow containers to receive traffic
    Value: !Ref 'ContainerSecurityGroup'
  ECSAutoScalingGroup:
    Description: ECS auto scaling group
    Value: !Ref ECSAutoScalingGroup
